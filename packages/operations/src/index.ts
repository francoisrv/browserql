import type {
  DocumentNode,
  FieldDefinitionNode,
  InputValueDefinitionNode,
} from 'graphql'
import {
  getArguments,
  getDefaultValue,
  getField,
  getKind,
  getMutation,
  getName,
  getQuery,
  getType,
  parseKind,
} from '@browserql/fpql'
import { buildFragment } from '@browserql/fragments'
import gql from 'graphql-tag'

/**
 *
 * @param field
 * @param schema
 */
export function printSelections(
  field: FieldDefinitionNode,
  schema: DocumentNode
) {
  const parsedType = parseKind(getKind(field))
  const isType = getType(parsedType.type)(schema)

  if (isType) {
    const fragment = buildFragment(schema, parsedType.type).trim()
    return fragment
      .replace(/^fragment .+ \{/, '{')
      .split('\n')
      .map((line) => `      ${line}`)
      .join('\n')
      .trim()
  }

  return ''
}

/**
 * Return an object representing a field's arguments
 * @param {DocumentNode} schema The GraphQL definitions
 * @param {string} path The path to the field, using dot notation, ie `Type.field`
 * @example buildArguments(schema, 'Query.getUserById') // { id: 'ID!' }
 */
export function buildArguments(
  schema: DocumentNode,
  path: string
): Record<string, string> {
  const object: Record<string, string> = {}

  const [typeName, fieldName] = path.split(/\./)
  let field: FieldDefinitionNode

  if (typeName === 'Query') {
    field = getQuery(fieldName)(schema) as FieldDefinitionNode
  } else if (typeName === 'Mutation') {
    field = getMutation(fieldName)(schema) as FieldDefinitionNode
  } else {
    const type = getType(typeName)(schema)
    if (!type) {
      console.warn(`Type not found in schema: ${typeName}`)
      return object
    }
    field = getField(fieldName)(type) as FieldDefinitionNode
  }

  if (!field) {
    console.warn(`Field not found in schema: ${path}`)
    return object
  }

  const args = getArguments(field) as InputValueDefinitionNode[]

  args.forEach((arg) => {
    let kind = getKind(arg)
    const val = getDefaultValue(arg)
    if (typeof val !== 'undefined') {
      kind += ` = ${JSON.stringify(val, null, 2)}`
    }
    object[getName(arg)] = kind
  })

  return object
}

type PrintArgumentsVariant =
  | { variant: 'define' }
  | { variant: 'assign'; assignments?: Record<string, string> }

type PrintArgumentsOptions = PrintArgumentsVariant | {}

/**
 * Print an object generated by buildArguments
 * @param {Record<string, string>} args An object generated by `buildArguments`
 * @param {number = 0} tab Optional -- indentation width
 * @example printArguments({ id: 'ID!' }) // "id: ID!"
 */
export function printArguments(
  args: Record<string, string>,
  tab = 0,
  options: PrintArgumentsOptions = {}
): string {
  return Object.keys(args)
    .map((field) => {
      if ('variant' in options) {
        if (options.variant === 'define') {
          return `${` `.repeat(tab)}$${field}: ${args[field]}`
        }
        if (options.variant === 'assign') {
          if (options.assignments && field in options.assignments) {
            return `${` `.repeat(tab)}${field}: $${options.assignments[field]}`
          }
          return `${` `.repeat(tab)}${field}: $${field}`
        }
      }
      return `${` `.repeat(tab)}${field}: ${args[field]}`
    })
    .join('\n')
}

/**
 * Print agnostic operation
 * @param schema GraphQL definitions
 * @param path The path to the field, using dot notation, ie `Type.field`
 */
export function printOperation(
  schema: DocumentNode,
  path: string
): string | undefined {
  const [typeName, fieldName] = path.split(/\./)
  let field: FieldDefinitionNode

  if (typeName === 'Query') {
    field = getQuery(fieldName)(schema) as FieldDefinitionNode
  } else if (typeName === 'Mutation') {
    field = getMutation(fieldName)(schema) as FieldDefinitionNode
  } else {
    const type = getType(typeName)(schema)
    if (!type) {
      console.warn(`Type not found in schema: ${typeName}`)
      return undefined
    }
    field = getField(fieldName)(type) as FieldDefinitionNode
  }

  if (!field) {
    console.warn(`Field not found in schema: ${path}`)
    return undefined
  }

  const selection = printSelections(field, schema)

  const args = buildArguments(schema, path)

  const hasArgs = Object.keys(args).length > 0

  const defs = printArguments(args, 4, { variant: 'define' })
  const fvars = printArguments(args, 6, { variant: 'assign' })

  const definitions = hasArgs ? `(\n  ${defs}\n)` : ''
  const variables = hasArgs ? `(\n  ${fvars}\n)` : ''

  return `${definitions}  {
  ${fieldName}${variables} ${selection}
}`
}

/**
 *
 * @param schema
 * @param path
 */
export function buildOperation(schema: DocumentNode, path: string) {
  const [typeName, fieldName] = path.split(/\./)
  return gql`
    ${typeName.toLowerCase}
    ${fieldName}
    ${printOperation(schema, path)}
  `
}

/**
 *
 * @param schema
 * @param queryName
 */
export function printQuery(schema: DocumentNode, queryName: string): string {
  const query = getQuery(queryName)(schema)
  if (!query) {
    throw new Error(`No such query: ${queryName}`)
  }
  return `query ${queryName}${printOperation(schema, `Query.${queryName}`)}`
}

/**
 *
 * @param schema
 * @param queryName
 */
export function buildQuery(
  schema: DocumentNode,
  queryName: string
): DocumentNode {
  return gql(printQuery(schema, queryName))
}

/**
 *
 * @param schema
 * @param mutationName
 */
export function printMutation(
  schema: DocumentNode,
  mutationName: string
): string {
  const mutation = getMutation(mutationName)(schema)
  if (!mutation) {
    throw new Error(`No such mutation: ${mutationName}`)
  }
  return `mutation ${mutationName}${printOperation(
    schema,
    `Mutation.${mutationName}`
  )}`
}

/**
 *
 * @param schema
 * @param mutationName
 */
export function buildMutation(
  schema: DocumentNode,
  mutationName: string
): DocumentNode {
  return gql(printMutation(schema, mutationName))
}

/**
 *
 * @param schema
 * @param variables
 * @param queries
 */
export function buildCompoundQuery(
  schema: DocumentNode,
  variables: Record<string, string>,
  ...queries: Array<
    string | [string] | [string, Record<string, keyof typeof variables>]
  >
) {
  let header = `query Query`
  if (Object.keys(variables).length) {
    header += '('
    header += Object.keys(variables).map(
      (variable) =>
        `${/^\$/.test(variable) ? variable : `$${variable}`}: ${
          variables[variable]
        }`
    )
    header += ')'
  }
  const normalized = queries.map((query) => {
    if (typeof query === 'string') {
      return [query]
    }
    return query
  }) as Array<[string, Record<string, string>]>
  const all = normalized.map(([queryName, queryVariables]) => {
    const defs = printArguments(
      buildArguments(schema, `Query.${queryName}`),
      0,
      { variant: 'assign' }
    )
    const query = getQuery(queryName)(schema) as FieldDefinitionNode
    let string = `  ${queryName}${defs ? `(${defs})` : ''}`
    string += printSelections(query, schema)
    return string
  })
  const allJoined = all.join('\n\n')
  const source = `
${header} {
${allJoined}
}
  `
  console.log(source)
  return gql(source)
}
