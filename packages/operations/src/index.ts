import type {
  DocumentNode,
  FieldDefinitionNode,
  InputValueDefinitionNode,
} from 'graphql'
import {
  getArguments,
  getDefaultValue,
  getField,
  getKind,
  getMutation,
  getName,
  getQuery,
  getType,
  parseKind,
} from '@browserql/fpql'
import { buildFragment } from '@browserql/fragments'
import gql from 'graphql-tag'

/**
 * Return an object representing a field's arguments
 * @param {DocumentNode} schema The GraphQL definitions
 * @param {string} path The path to the field, using dot notation, ie `Type.field`
 * @example buildArguments(schema, 'Query.getUserById') // { id: 'ID!' }
 */
export function buildArguments(
  schema: DocumentNode,
  path: string
): Record<string, string> {
  const object: Record<string, string> = {}

  const [typeName, fieldName] = path.split(/\./)
  let field: FieldDefinitionNode

  if (typeName === 'Query') {
    field = getQuery(fieldName)(schema) as FieldDefinitionNode
  } else if (typeName === 'Mutation') {
    field = getMutation(fieldName)(schema) as FieldDefinitionNode
  } else {
    const type = getType(typeName)(schema)
    if (!type) {
      console.warn(`Type not found in schema: ${typeName}`)
      return object
    }
    field = getField(fieldName)(type) as FieldDefinitionNode
  }

  if (!field) {
    console.warn(`Field not found in schema: ${path}`)
    return object
  }

  const args = getArguments(field) as InputValueDefinitionNode[]

  args.forEach((arg) => {
    let kind = getKind(arg)
    const val = getDefaultValue(arg)
    if (typeof val !== 'undefined') {
      kind += ` = ${JSON.stringify(val, null, 2)}`
    }
    object[getName(arg)] = kind
  })

  return object
}

/**
 * Print an object generated by buildArguments
 * @param {Record<string, string>} args An object generated by `buildArguments`
 * @param {number = 0} tab Optional -- indentation width
 * @example printArguments({ id: 'ID!' }) // "id: ID!"
 */
export function printArguments(args: Record<string, string>, tab = 0): string {
  return Object.keys(args)
    .map((field) => `${` `.repeat(tab)}${field}: ${args[field]}`)
    .join('\n')
}

export function buildOperationString(
  schema: DocumentNode,
  path: string
): string | undefined {
  const [typeName, fieldName] = path.split(/\./)
  let field: FieldDefinitionNode

  if (typeName === 'Query') {
    field = getQuery(fieldName)(schema) as FieldDefinitionNode
  } else if (typeName === 'Mutation') {
    field = getMutation(fieldName)(schema) as FieldDefinitionNode
  } else {
    const type = getType(typeName)(schema)
    if (!type) {
      console.warn(`Type not found in schema: ${typeName}`)
      return undefined
    }
    field = getField(fieldName)(type) as FieldDefinitionNode
  }

  if (!field) {
    console.warn(`Field not found in schema: ${path}`)
    return undefined
  }

  const parsedType = parseKind(getKind(field))
  const isType = getType(parsedType.type)(schema)

  let selection = ''

  if (isType) {
    const fragment = buildFragment(schema, parsedType.type).trim()
    selection = fragment
      .replace(/^fragment .+ \{/, '{')
      .split('\n')
      .map((line) => `      ${line}`)
      .join('\n')
      .trim()
  }

  const args = buildArguments(schema, path)

  const hasArgs = Object.keys(args).length > 0

  const defArgs: Record<string, string> = {}
  const fieldArgs: Record<string, string> = {}

  for (const arg in args) {
    defArgs[`$${arg}`] = args[arg]
    fieldArgs[arg] = `$${arg}`
  }

  const defs = printArguments(defArgs, 4)
  const fvars = printArguments(fieldArgs, 6)

  let definitions = hasArgs ? `(\n  ${defs}\n)` : ''
  let variables = hasArgs ? `(\n  ${fvars}\n)` : ''

  return `${definitions}  {
  ${fieldName}${variables} ${selection}
}`
}

export function buildQueryString(
  schema: DocumentNode,
  queryName: string
): string {
  const query = getQuery(queryName)(schema)
  if (!query) {
    throw new Error(`No such query: ${queryName}`)
  }
  return `query ${queryName}${buildOperationString(
    schema,
    `Query.${queryName}`
  )}`
}

export function buildQuery(
  schema: DocumentNode,
  queryName: string
): DocumentNode {
  return gql(buildQueryString(schema, queryName))
}

export function buildMutationString(
  schema: DocumentNode,
  mutationName: string
): string {
  const mutation = getMutation(mutationName)(schema)
  if (!mutation) {
    throw new Error(`No such mutation: ${mutationName}`)
  }
  return `mutation ${mutationName}${buildOperationString(
    schema,
    `Mutation.${mutationName}`
  )}`
}

export function buildMutation(
  schema: DocumentNode,
  mutationName: string
): DocumentNode {
  return gql(buildMutationString(schema, mutationName))
}

export function buildCompoundQuery(
  schema: DocumentNode,
  variables: Record<string, string>,
  ...queries: Array<
    string | [string] | [string, Record<string, keyof typeof variables>]
  >
) {
  let header = `query Query`
  if (Object.keys(variables).length) {
    header += '('
    header += Object.keys(variables).map(
      (variable) =>
        `${/^\$/.test(variable) ? variable : `$${variable}`}: ${
          variables[variable]
        }`
    )
    header += ')'
  }
  const normalized = queries.map((query) => {
    if (typeof query === 'string') {
      return [query]
    }
    return query
  }) as Array<[string, Record<string, string>]>
  const all = normalized.map(([queryName, queryVariables]) => {
    const op = (buildOperationString(schema, `Query.${queryName}`) || '')
      .trim()
      .split(/\n/)
    return op
      .map((line, index) => {
        if (index === 0 && queryVariables) {
          let nextLine = line
          for (const key in queryVariables) {
            nextLine = nextLine.replace(
              new RegExp(`\\$${key}(\\W)`),
              (/^\$/.test(queryVariables[key])
                ? queryVariables[key]
                : `$${queryVariables[key]}`
              ).concat('$1')
            )
          }
          return `  ${nextLine.trim()}`
        }
        return `  ${line}`
      })
      .join('\n')
  })
  const allJoined = all.join('\n\n')
  const source = `
${header} {
${allJoined}
}
  `
  console.log(source)
  return gql(source)
}
