# Executable

Build a `GraphQL` executable query or mutation from a definition schema.

## Build executable query

```graphql
type User {
  id: ID!
  email: String!
  isVerified: Boolean!
}

type Query {
  getUser(userID: ID!, isVerified: Boolean = false): User
}
```

```javascript
import { makeExecutableQuery } from '@browserql/executable'

makeExecutableQuery(schema, 'getUser')
```

```snapshot
Operations.BuildQueryExample
```

## Build executable mutation

```graphql
type User {
  id: ID!
  email: String!
}

type Mutation {
  addUser(email: String!): User
}
```

```javascript
import { buildMutation } from '@browserql/operations'

buildMutation(schema, 'addUser')
```

```snapshot
Operations.BuildMutationExample
```

## Coumpound queries

Sometimes you want to create a compound query. For this use `buildCompoundQuery`.

Take these queries for example:

```graphql
type Query {
  getUserById(id: ID!): User!
  getUserTags(userId: ID!): [Tag]!
  getUserBadges(userId: ID!): [Badge]!
}
```

You could group them like this

```javascript
import { makeExecutableQuery } from '@browserql/executable'

makeExecutableQuery(
  gql`
    type Query {
      getUserById(id: ID!): User!
      getUserTags(userId: ID!): [Tag]!
      getUserBadges(userId: ID!): [Badge]!
    }
  `,
  { userId: 'ID!' },
  // Then put a list of queries to include by name
  'getUserTags',
  'getUserBadges',
  // You can assign a query field to a variable like this:
  ('getUserById', { id: 'userId' })
)
```

```snapshot
Operations.BuildCompoundQueryExample
```

## Build operation

Bothe `buildQuery` and `buildMutation` are actually built on top of the `buildOperation` function

```graphql
type Foo {
  get(id: ID!): String!
}
```

```javascript
import { buildOperation } from '@browserql/operations'

buildOperation(schema, 'Foo.get')
```

## Accessories

### `buildArguments`

For a given field, returns an object with the fields and their types.

```javascript
import { buildArguments } from '@browserql/operations'
import gql from 'graphql-tag'

buildArguments(
  gql`
    type Query {
      getUsers(isVerified: Boolean = false, limit: Int = 100): [User!]!
    }
  `,
  'Query.getUsers'
)
```

```snapshot
Operations.BuildArguments
```

### `printArguments`

Print an object generated by `buildArguments`

```javascript
import { buildArguments, printArguments } from '@browserql/operations'

printArguments(buildArguments(schema, 'Query.getUser'))
```

```snapshot
Operations.PrintArguments
```

You can specify the indentation too:

```javascript
printArguments(buildArguments(schema, 'Query.getUser'), 8)
```

```snapshot
Operations.PrintArgumentsWithTab
```

You can also use variants, such as:

- define
- assign

### define variant

If you use this variant to denote variables with `$`

```javascript
printArguments(buildArguments(schema, 'Query.getUser'), 0, {
  variant: 'define',
})
```

```snapshot
Operations.PrintArgumentsWithDefineVariant
```

### assign variant

In this case, you will assign the name of the field as a variable. You can overwrite the variable name usign `assignments`

```javascript
printArguments(buildArguments(schema, 'Query.getUser'), 0, {
  variant: 'assign',
  assignments: {
    id: '$userId',
  },
})
```

```snapshot
Operations.PrintArgumentsWithAssignVariant
```
